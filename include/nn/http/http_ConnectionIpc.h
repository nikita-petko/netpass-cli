//
// This file is automatically generated.
// Do not edit this file.
//

#ifndef NN_HTTP_HTTP_CONNECTIONIPC_H_
#define NN_HTTP_HTTP_CONNECTIONIPC_H_

#include <nn/Handle.h>
#include <nn/Result.h>
#include <nn/types.h>
#include <nn/http/http_Types.h>
#include <nn/http/http_Const.h>
#include <nn/http/http_Result.h>



namespace nn {
namespace http {

    class ConnectionIpc
    {
    public:
        enum Tag
        {
            TAG_IPC_ERROR,
            TAG_INITIALIZE_GENERAL_SESSION                       = 0x0001,
            TAG_CREATE_CONNECTION                                = 0x0002,
            TAG_DESTROY_CONNECTION                               = 0x0003,
            TAG_CANCEL_CONNECTION                                = 0x0004,
            TAG_GET_CONNECTION_STATUS                            = 0x0005,
            TAG_GET_CONNECTION_PROGRESS                          = 0x0006,
            TAG_GET_CONNECTION_ERROR                             = 0x0007,
            TAG_INITIALIZE_CONNECTION_SESSION                    = 0x0008,
            TAG_START_CONNECTION                                 = 0x0009,
            TAG_START_CONNECTION_ASYNC                           = 0x000a,
            TAG_READ_BODY                                        = 0x000b,
            TAG_READ_BODY_WITH_TIMEOUT                           = 0x000c,
            TAG_SET_PROXY                                        = 0x000d,
            TAG_SET_PROXY_DEFAULT                                = 0x000e,
            TAG_SET_BASIC_AUTHORIZATION                          = 0x000f,
            TAG_SET_SOCKET_BUFFER_SIZE                           = 0x0010,
            TAG_ADD_HEADER_FIELD                                 = 0x0011,
            TAG_ADD_POST_DATA_ASCII                              = 0x0012,
            TAG_ADD_POST_DATA_BINARY                             = 0x0013,
            TAG_ADD_POST_DATA_RAW                                = 0x0014,
            TAG_SET_LAZY_POST_DATA_SETTING                       = 0x0015,
            TAG_SEND_POST_DATA_ASCII                             = 0x0016,
            TAG_SEND_POST_DATA_ASCII_WITH_TIMEOUT                = 0x0017,
            TAG_SEND_POST_DATA_BINARY                            = 0x0018,
            TAG_SEND_POST_DATA_BINARY_WITH_TIMEOUT               = 0x0019,
            TAG_SEND_POST_DATA_RAW                               = 0x001a,
            TAG_SEND_POST_DATA_RAW_WITH_TIMEOUT                  = 0x001b,
            TAG_SET_POST_DATA_ENCODING                           = 0x001c,
            TAG_NOFITY_FINISH_SEND_POST_DATA                     = 0x001d,
            TAG_GET_HEADER_FIELD                                 = 0x001e,
            TAG_GET_HEADER_FIELD_WITH_TIMEOUT                    = 0x001f,
            TAG_GET_HEADER_ALL                                   = 0x0020,
            TAG_GET_HEADER_ALL_WITH_TIMEOUT                      = 0x0021,
            TAG_GET_RESULT_CODE                                  = 0x0022,
            TAG_GET_RESULT_CODE_WITH_TIMEOUT                     = 0x0023,
            TAG_SET_ROOT_CA                                      = 0x0024,
            TAG_SET_INTERNAL_ROOT_CA                             = 0x0025,
            TAG_SET_ROOT_CA_STORE                                = 0x0026,
            TAG_SET_CLIENT_CERT                                  = 0x0027,
            TAG_SET_INTERNAL_CLIENT_CERT                         = 0x0028,
            TAG_SET_CLIENT_CERT_ID                               = 0x0029,
            TAG_GET_CONNECTION_SSL_ERROR                         = 0x002a,
            TAG_SET_VERIFY_OPTION                                = 0x002b,
            TAG_DISABLE_VERIFY_OPTION_FOR_DEBUG                  = 0x002c,
            TAG_CREATE_CERT_STORE                                = 0x002d,
            TAG_DESTROY_CERT_STORE                               = 0x002e,
            TAG_ADD_CERT_TO_CERT_STORE                           = 0x002f,
            TAG_ADD_INTERNAL_CERT_TO_CERT_STORE                  = 0x0030,
            TAG_REMOVE_CERT_FROM_CERT_STORE                      = 0x0031,
            TAG_CREATE_CLIENT_CERT                               = 0x0032,
            TAG_CREATE_INTERNAL_CLIENT_CERT                      = 0x0033,
            TAG_DESTROY_CLIENT_CERT                              = 0x0034,
            TAG_SET_DEFAULT_PROXY                                = 0x0035,
            TAG_CLEAR_DNS_CACHES                                 = 0x0036,
            TAG_SET_KEEP_ALIVE_AVAILABILITY                      = 0x0037,
            TAG_SET_LAZY_POST_DATA_SETTING_WITH_SIZE             = 0x0038,
            TAG_FINALIZE_CLIENT                                  = 0x0039,
            TAG_IPC_END
        };

    private:
        Handle m_Session;

    public:
        ConnectionIpc(Handle session) : m_Session(session) {}

    public:
        nn::Result InitializeGeneralSession( nn::Handle hSharedMemory, size_t size );
        nn::Result CreateConnection( const char8 url[], size_t urlLen, RequestMethod reqMethod, ConnectionHandle* handleCourier );
        nn::Result DestroyConnection( ConnectionHandle handle );
        nn::Result CancelConnection( ConnectionHandle handle );
        nn::Result GetConnectionStatus( ConnectionHandle handle, Status* statusCourier );
        nn::Result GetConnectionProgress( ConnectionHandle handle, size_t* receivedSizeCourier, size_t* contentSizeCourier );
        nn::Result GetConnectionError( ConnectionHandle handle, ResultCode* resultCodeCourier );
        nn::Result InitializeConnectionSession( ConnectionHandle handle );
        nn::Result StartConnection( ConnectionHandle handle );
        nn::Result StartConnectionAsync( ConnectionHandle handle );
        nn::Result ReadBody( ConnectionHandle handle, u8 bodyCourier[], size_t bodyCourierLen );
        nn::Result ReadBodyWithTimeout( ConnectionHandle handle, u8 bodyCourier[], size_t bodyCourierLen, s64 timeout );
        nn::Result SetProxy( ConnectionHandle handle, const char8 proxyName[], size_t proxyNameLen, u16 port, const char8 userName[], size_t userNameLen, const char8 password[], size_t passwordLen );
        nn::Result SetProxyDefault( ConnectionHandle handle );
        nn::Result SetBasicAuthorization( ConnectionHandle handle, const char8 userName[], size_t userNameLen, const char8 password[], size_t passwordLen );
        nn::Result SetSocketBufferSize( ConnectionHandle handle, u32 bufSize );
        nn::Result AddHeaderField( ConnectionHandle handle, const char8 label[], size_t labelLen, const char8 value[], size_t valueLen );
        nn::Result AddPostDataAscii( ConnectionHandle handle, const char8 label[], size_t labelLen, const char8 value[], size_t valueLen );
        nn::Result AddPostDataBinary( ConnectionHandle handle, const char8 label[], size_t labelLen, const u8 value[], size_t valueLen );
        nn::Result AddPostDataRaw( ConnectionHandle handle, const u8 value[], size_t valueLen );
        nn::Result SetLazyPostDataSetting( ConnectionHandle handle, PostDataType dataType );
        nn::Result SendPostDataAscii( ConnectionHandle handle, const char8 label[], size_t labelLen, const char8 value[], size_t valueLen );
        nn::Result SendPostDataAsciiWithTimeout( ConnectionHandle handle, const char8 label[], size_t labelLen, const char8 value[], size_t valueLen, s64 timeout );
        nn::Result SendPostDataBinary( ConnectionHandle handle, const char8 label[], size_t labelLen, const u8 value[], size_t valueLen );
        nn::Result SendPostDataBinaryWithTimeout( ConnectionHandle handle, const char8 label[], size_t labelLen, const u8 value[], size_t valueLen, s64 timeout );
        nn::Result SendPostDataRaw( ConnectionHandle handle, const u8 value[], size_t valueLen );
        nn::Result SendPostDataRawWithTimeout( ConnectionHandle handle, const u8 value[], size_t valueLen, s64 timeout );
        nn::Result SetPostDataEncoding( ConnectionHandle handle, EncodingType encodeType );
        nn::Result NofityFinishSendPostData( ConnectionHandle handle );
        nn::Result GetHeaderField( ConnectionHandle handle, const char8 label[], size_t labelLen, char8 valueCourier[], size_t valueCourierLen, u32* fieldLenCourier );
        nn::Result GetHeaderFieldWithTimeout( ConnectionHandle handle, const char8 label[], size_t labelLen, char8 valueCourier[], size_t valueCourierLen, u32* fieldLenCourier, s64 timeout );
        nn::Result GetHeaderAll( ConnectionHandle handle, char8 headerCourier[], size_t headerCourierLen, u32* allHeaderLenCourier );
        nn::Result GetHeaderAllWithTimeout( ConnectionHandle handle, char8 headerCourier[], size_t headerCourierLen, u32* allHeaderLenCourier, s64 timeout );
        nn::Result GetResultCode( ConnectionHandle handle, s32* resultCodeCourier );
        nn::Result GetResultCodeWithTimeout( ConnectionHandle handle, s32* resultCodeCourier, s64 timeout );
        nn::Result SetRootCA( ConnectionHandle handle, const u8 rootCaData[], size_t rootCaDataLen );
        nn::Result SetInternalRootCA( ConnectionHandle handle, InternalCaCertId inCaCertName );
        nn::Result SetRootCaStore( ConnectionHandle handle, CertStoreId certStoreId );
        nn::Result SetClientCert( ConnectionHandle handle, const u8 clientCertData[], size_t clientCertDataLen, const u8 privateKeyData[], size_t privateKeyDataLen );
        nn::Result SetInternalClientCert( ConnectionHandle handle, InternalClientCertId inClientCertName );
        nn::Result SetClientCertId( ConnectionHandle handle, CertId clientCertId );
        nn::Result GetConnectionSslError( ConnectionHandle handle, s32* resultCodeCourier );
        nn::Result SetVerifyOption( ConnectionHandle handle, u32 verifyOption );
        nn::Result DisableVerifyOptionForDebug( ConnectionHandle handle, u32 verifyOption );
        nn::Result CreateCertStore( CertStoreId* pCertId );
        nn::Result DestroyCertStore( CertStoreId certId );
        nn::Result AddCertToCertStore( CertStoreId certStoreId, const u8 pCertData[], size_t certDataSize, CertId* pCertId );
        nn::Result AddInternalCertToCertStore( CertStoreId certStoreId, InternalCaCertId inCaCertName, CertId* pCertId );
        nn::Result RemoveCertFromCertStore( CertStoreId certStoreId, CertId certId );
        nn::Result CreateClientCert( const u8 pCertData[], size_t certDataSize, const u8 pPrivateKeyData[], size_t privateKeyDataSize, CertId* pCertId );
        nn::Result CreateInternalClientCert( InternalClientCertId inClientCertName, CertId* pCertId );
        nn::Result DestroyClientCert( CertId ClientCert );
        nn::Result SetDefaultProxy( bool isEnableProxy, ProxyAuthType authType, u16 port, const char8 hostName[], size_t hostNameLen, const char8 username[], size_t usernameLen, const char8 password[], size_t passwordLen );
        nn::Result ClearDnsCaches();
        nn::Result SetKeepAliveAvailability( ConnectionHandle handle, bool isUseKeepAlive );
        nn::Result SetLazyPostDataSettingWithSize( ConnectionHandle handle, PostDataType dataType, size_t dataLen );
        nn::Result FinalizeClient();
    };

} // end of namespace http
} // end of namespace nn



#endif  // ifndef NN_HTTP_HTTP_CONNECTIONIPC_H_
